
require 'Coat'

local ipairs = ipairs

singleton 'Smc.Scala'
extends 'Smc.Language'

has.id              = { '+', default = 'SCALA' }
has.name            = { '+', default = 'Scala' }
has.option          = { '+', default = '-scala' }
has.suffix          = { '+', default = 'Context' }
has.generator       = { '+', isa = 'Smc.Scala.Generator',
                        default = function () return require 'Smc.Scala.Generator' end }
has.reflectFlag     = { '+', default = true }
has.serialFlag      = { '+', default = true }
has.syncFlag        = { '+', default = true }


class 'Smc.Scala.Generator'
extends 'Smc.Generator'

has.suffix          = { '+', default = 'scala' }

function method:visitFSM (fsm)
    local stream = self.stream
    stream:write "// ex: set ro:\n"
    stream:write "// DO NOT EDIT.\n"
--    stream:write "// generated by smc (http://smc.sourceforge.net/)\n"
    stream:write("// from file : ", fsm.filename, "\n")
    if fsm.source then
        stream:write "\n"
        stream:write(fsm.source, "\n")
    end
    if fsm._package then
        stream:write "\n"
        stream:write("package ", fsm._package, "\n")
    end
    if self.syncFlag then
        stream:write "\n"
        stream:write "import scala.concurrent\n"
    end
    for _, imp in ipairs(fsm.importList) do
        stream:write("import ", imp, "\n")
    end
    stream:write "\n"
    if self.serialFlag then
        stream:write "@serializable\n"
    end
    local fsmClassName = fsm.fsmClassname
    local context = fsm.context
    stream:write("class ", fsmClassName, "(owner: ", context, ") extends statemap.FSMContext[", context, "State] {\n")
    stream:write("    private val _owner: ", context, " = owner\n")
    stream:write "\n"
    stream:write("    setState(", fsm.startState:gsub("::", "."), ")\n")
    stream:write "\n"
    for _, trans in ipairs(fsm.transitions) do
        local transName = trans.name
        if transName ~= "Default" then
            stream:write("    def ", transName, "(")
            local sep = ""
            for _, param in ipairs(trans.parameters) do
                stream:write(sep)
                param:visit(self)
                sep = ", "
            end
            stream:write "): Unit = "
            if self.syncFlag then
                stream:write "synchronized "
            end
            stream:write "{\n"
            stream:write("        _transition = \"", transName, "\"\n")
            stream:write("        getState().", transName, "(this")
            for _, param in ipairs(trans.parameters) do
                stream:write(", ", param.name)
            end
            stream:write ")\n"
            stream:write "        _transition = \"\"\n"
            stream:write "    }\n"
            stream:write "\n"
        end
    end
    stream:write "    override def enterStartState(): Unit = {\n"
    stream:write "        getState().Entry(this)\n"
    stream:write "    }\n"
    stream:write "\n"
    stream:write("    def getOwner(): ", context, " = _owner\n")
    if self.reflectFlag then
        stream:write "\n"
        stream:write("    def getStates(): List[", context, "State] = List(\n")
        local sep = ""
        for _, map in ipairs(fsm.maps) do
            local mapName = map.name
            for _, state in ipairs(map.states) do
                stream:write(sep, "        ", mapName, ".", state.className)
                sep = ",\n"
            end
        end
        stream:write "\n"
        stream:write "    )\n"
        stream:write "\n"
        stream:write "    def getTransitions(): List[String] = List(\n"
        sep = ""
        for _, trans in ipairs(fsm.transitions) do
            stream:write(sep, "        \"", trans.name, "\"")
            sep = ",\n"
        end
        stream:write "\n"
        stream:write "    )\n"
    end
    stream:write "}\n"
    stream:write "\n"
    if self.serialFlag then
        stream:write "@serializable\n"
    end
    stream:write("class ", context, "State(name: String, id: Int) {\n")
    stream:write "    private val _name = name\n"
    stream:write "    private val _id = id\n"
    stream:write "\n"
    stream:write "    def getName(): String = _name\n"
    stream:write "\n"
    stream:write "    override def toString(): String = _name\n"
    stream:write "\n"
    stream:write("    def Entry(context: ", fsmClassName, "): Unit = {}\n")
    stream:write("    def Exit(context: ", fsmClassName, "): Unit = {}\n")
    stream:write "\n"
    for _, trans in ipairs(fsm.transitions) do
        local transName = trans.name
        if transName ~= "Default" then
            stream:write("    def ", transName, "(context: ", fsmClassName)
            for _, param in ipairs(trans.parameters) do
                stream:write ", "
                param:visit(self)
            end
            stream:write "): Unit = {\n"
            stream:write "        Default(context)\n"
            stream:write "    }\n"
            stream:write "\n"
        end
    end
    stream:write("    def Default(context: ", fsmClassName, "): Unit = {\n")
    if self.debugLevel >= 0 then
        stream:write "        if (context.getDebugFlag())\n"
        stream:write "            context.getDebugStream().println(\"TRANSITION   : Default\")\n"
        stream:write "\n"
    end
    stream:write "        throw new statemap.TransitionUndefinedException(\n"
    stream:write "                \"State: \" + context.getState()._name +\n"
    stream:write "                \", Transition: \" + context.getTransition())\n"
    stream:write "    }"
    stream:write "\n"
    stream:write "}\n"
    stream:write "\n"
    for _, map in ipairs(fsm.maps) do
        map:visit(self)
    end
end

function method:visitMap (map)
    local stream = self.stream
    local mapName = map.name
    local fsm = map.fsm
    local context = fsm.context
    stream:write("private class ", mapName, "_Default(name: String, id: Int) extends ", context, "State(name, id) {\n")
    local defaultState = map.defaultState
    if defaultState then
        for _, trans in ipairs(defaultState.transitions) do
            trans:visit(self)
        end
    end
    if self.reflectFlag then
        stream:write "\n"
        stream:write "    def getTransitions(): Map[String, Int] = Map(\n"
        local sep = ""
        for _, trans in ipairs(fsm.transitions) do
            local transName = trans.name
            local transDefinition
            if defaultState and defaultState:findTransition(transName) then
                transDefinition = 2
            else
                transDefinition = 0
            end
            stream:write(sep, "        \"", transName, "\" -> ", transDefinition)
            sep = ",\n"
        end
        stream:write "\n"
        stream:write "    )\n"
    end
    stream:write "}\n"
    for _, state in ipairs(map.states) do
        state:visit(self)
    end
    stream:write "\n"
    stream:write("private object ", mapName, " {\n")
    for _, state in ipairs(map.states) do
        stream:write("    val ", state.instanceName, " = new ", mapName, "_", state.className,
                        "(\"", mapName, ".", state.className, "\", ", map.nextStateId, ")\n")
    end
    stream:write("    val Default = new ", mapName, "_Default(\"", mapName, ".Default\", -1)\n")
    stream:write "}\n"
    stream:write "\n"
end

function method:visitState (state)
    local stream = self.stream
    local map = state.map
    local mapName = map.name
    local stateName = state.className
    stream:write "\n"
    stream:write("private class ", mapName, "_", stateName, "(name: String, id: Int) extends ", mapName, "_Default(name, id) {\n")
    local fsmClassName = map.fsm.fsmClassname
    local actions = state.entryActions
    if actions and #actions > 0 then
        stream:write "\n"
        stream:write("    override def Entry (context: ", fsmClassName, "): Unit = {\n")
        stream:write "        val ctxt = context.getOwner()\n"
        stream:write "\n"
        for _, action in ipairs(actions) do
            action:visit(self, self.indent(8))
        end
        stream:write "    }\n"
    end
    actions = state.exitActions
    if actions and #actions > 0 then
        stream:write "\n"
        stream:write("    override def Exit (context: ", fsmClassName, "): Unit = {\n")
        stream:write "        val ctxt = context.getOwner()\n"
        stream:write "\n"
        for _, action in ipairs(actions) do
            action:visit(self, self.indent(8))
        end
        stream:write "    }\n"
    end
    for _, trans in ipairs(state.transitions) do
        trans:visit(self)
    end
    if self.reflectFlag then
        local defaultState = map.defaultState
        stream:write "\n"
        stream:write "    override def getTransitions(): Map[String, Int] = Map(\n"
        local sep = ""
        for _, trans in ipairs(map.fsm.transitions) do
            local transName = trans.name
            local transDefinition
            if state:findTransition(transName) then
                transDefinition = 1
            elseif defaultState and defaultState:findTransition(transName) then
                transDefinition = 2
            else
                transDefinition = 0
            end
            stream:write(sep, "        \"", transName, "\" -> ", transDefinition)
            sep = ",\n"
        end
        stream:write "\n"
        stream:write "    )\n"
    end
    stream:write "}\n"
end

function method:visitTransition (transition)
    local stream = self.stream
    local transName = transition.name
    local state = transition.state
    local map = state.map
    local fsm = map.fsm
    local fsmClassName = fsm.fsmClassname
    stream:write "\n"
    stream:write("    override def ", transName, "(context: ", fsmClassName)
    for _, param in ipairs(transition.parameters) do
        stream:write ", "
        param:visit(self)
    end
    stream:write "): Unit = {\n"
    if transition.hasCtxtReference then
        local context = fsm.context
        stream:write("        val ctxt: ", context, " = context.getOwner()\n")
        stream:write "\n"
    end
    if self.debugLevel >= 0 then
        local mapName = map.name
        local stateName = state.className
        stream:write("        if (context.getDebugFlag())\n")
        stream:write("            context.getDebugStream().println(\"LEAVING STATE   : ", mapName, ".", stateName, "\")\n")
    end
    local guards = transition.guards
    self.guardIndex = 0
    self.guardCount = #guards
    local nullCondition = false
    for _, guard in ipairs(guards) do
        if guard.condition == '' then
            nullCondition = true
        end
        guard:visit(self)
        self.guardIndex = self.guardIndex + 1
    end
    if self.guardIndex > 0 and not nullCondition then
        if self.guardCount == 1 then
            stream:write("        }\n")
        end
        stream:write("        else {\n")
        stream:write("            super.", transName, "(context")
        for _, param in ipairs(transition.parameters) do
            stream:write(", ", param.name)
        end
        stream:write ")\n"
        stream:write("        }\n")
        stream:write "\n"
    elseif self.guardCount > 1 then
        stream:write "\n"
        stream:write "\n"
    end
    stream:write("    }\n")
end

function method:visitGuard (guard)
    local stream = self.stream
    local condition = guard.condition
    local indent2
    if condition == '' and self.guardCount == 1 then
        indent2 = self.indent(8)
    else
        indent2 = self.indent(12)
        if self.guardIndex == 0 and condition ~= '' then
            stream:write("        if (", condition, ") {\n")
        elseif condition ~= '' then
            stream:write "\n"
            stream:write("        else if (", condition, ") {\n")
        else
            stream:write "\n"
            stream:write("        else {\n")
        end
    end

    local transition = guard.transition
    local state = transition.state
    local map = state.map
    local mapName = map.name
    local transName = transition.name
    local transType = guard.transType
    local actions = guard.actions or {}
    local endStateName = guard.endState
    if transType ~= 'TRANS_POP' and endStateName ~= 'nil' then
        endStateName = self:scopeStateName(endStateName, mapName)
    end
    local fqEndStateName = ""
    local stateName = self:scopeStateName(state.className, mapName)
    local packageName = map.fsm._package
    if packageName then
        stateName = packageName .. "." .. stateName
    end
    local loopbackFlag = self:isLoopback(transType, endStateName)

    if #actions == 0 and endStateName:len() ~= 0 then
        fqEndStateName = endStateName
    elseif #actions > 0 then
        if loopbackFlag then
            fqEndStateName = "endState";
            stream:write(indent2, "val ", fqEndStateName, " = context.getState()\n")
        else
            fqEndStateName = endStateName;
        end
    end
    stream:write "\n"

    if transType == 'TRANS_POP' or not loopbackFlag then
        if self.debugLevel >= 1 then
            stream:write(indent2, "if (context.getDebugFlag())\n")
            stream:write(indent2, "    context.getDebugStream().println(\"BEFORE EXIT     : ", stateName, ".Exit(fsm)\")\n")
        end
        stream:write(indent2, "context.getState().Exit(context)\n")
        if self.debugLevel >= 1 then
            stream:write(indent2, "if (context.getDebugFlag())\n")
            stream:write(indent2, "    context.getDebugStream().println(\"AFTER EXIT      : ", stateName, ".Exit(fsm)\")\n")
        end
    end

    if self.debugLevel >= 0 then
        stream:write(indent2, "if (context.getDebugFlag())\n")
        stream:write(indent2, "    context.getDebugStream().println(\"ENTER TRANSITION: ", stateName, ".", transName, "(")
        local sep = ""
        for _, param in ipairs(transition.parameters) do
            stream:write(sep)
            param:visit(self)
            sep = ", "
        end
        stream:write ")\")\n"
    end

    local indent3 = indent2
    if #actions == 0 then
        if condition ~= '' then
            stream:write(indent2, "// No actions.\n")
        end
    else
        stream:write(indent2, "context.clearState()\n")
        if not self.noCatchFlag then
            stream:write(indent2, "try {\n")
            indent3 = indent2 .. self.indent(4)
        end
        for _, action in ipairs(actions) do
            action:visit(self, indent3)
        end
        if not self.noCatchFlag then
            stream:write(indent2, "}\n")
            stream:write(indent2, "finally {\n")
        end
    end

    if self.debugLevel >= 0 then
        stream:write(indent3, "if (context.getDebugFlag())\n")
        stream:write(indent3, "    context.getDebugStream().println(\"EXIT TRANSITION : ", stateName, ".", transName, "(")
        local sep = ""
        for _, param in ipairs(transition.parameters) do
            stream:write(sep)
            param:visit(self)
            sep = ", "
        end
        stream:write ")\")\n"
    end

    if transType == 'TRANS_SET' and (not loopbackFlag or #actions > 0) then
        stream:write(indent3, "context.setState(", fqEndStateName, ")\n")
    elseif transType == 'TRANS_PUSH' then
        if not loopbackFlag or #actions > 0 then
            stream:write(indent3, "context.setState(", fqEndStateName, ")\n")
        end

        if not loopbackFlag then
            if self.debugLevel >= 1 then
                stream:write(indent3, "if (context.getDebugFlag())\n")
                stream:write(indent3, "    context.getDebugStream().println(\"BEFORE ENTRY    : ", stateName, ".Entry(fsm)\")\n")
            end
            stream:write(indent3, "context.getState().Entry(context)\n")
            if self.debugLevel >= 1 then
                stream:write(indent3, "if (context.getDebugFlag())\n")
                stream:write(indent3, "    context.getDebugStream().println(\"AFTER ENTRY     : ", stateName, ".Entry(fsm)\")\n")
            end
        end
        local pushStateName = self:scopeStateName(guard.pushState, mapName)
        stream:write(indent3, "context.pushState(", pushStateName, ")\n")
    elseif transType == 'TRANS_POP' then
        stream:write(indent3, "context.popState()\n")
    end

    if (transType == 'TRANS_SET' and not loopbackFlag) or transType == 'TRANS_PUSH' then
        if self.debugLevel >= 1 then
            stream:write(indent3, "if (context.getDebugFlag())\n")
            stream:write(indent3, "    context.getDebugStream().println(\"BEFORE ENTRY    : ", stateName, ".Entry(fsm)\")\n")
        end
        stream:write(indent3, "context.getState().Entry(context)\n")
        if self.debugLevel >= 1 then
            stream:write(indent3, "if (context.getDebugFlag())\n")
            stream:write(indent3, "    context.getDebugStream().println(\"AFTER ENTRY     : ", stateName, ".Entry(fsm)\")\n")
        end
    end

    if #actions > 0 and not self.noCatchFlag then
        stream:write(indent2, "}\n")
    end

    if transType == 'TRANS_POP' and endStateName ~= 'nil' then
        stream:write "\n"
        stream:write(indent2, "context.", endStateName, "(", guard.popArgs, ")\n")
    end

    if self.guardCount > 1 then
        stream:write("        }\n")
    end
end

function method:visitAction (action, indent)
    local stream = self.stream
    stream:write(indent)
    if action.propertyFlag then
        stream:write("ctxt.", action.name, " = ", action.arguments[1], "\n")
    else
        if action.isEmptyStateStack then
            stream:write "context.emptyStateStack()\n"
        else
            local args = table.concat(action.arguments or {}, ", ")
            stream:write("ctxt.", action.name, "(", args, ")\n")
        end
    end
end

function method:visitParameter (parameter)
    local stream = self.stream
    stream:write(parameter.name, ": ", parameter._type)
end
