
require 'Coat'

singleton 'Smc.C'
extends 'Smc.Language'

has.id              = { '+', default = 'C' }
has.name            = { '+', default = 'C' }
has.option          = { '+', default = '-c' }
has.suffix          = { '+', default = '_sm' }
has.generator       = { '+', isa = 'Smc.C.Generator',
                        default = function () return require 'Smc.C.Generator' end }
has.headerFlag      = { '+', default = true }


class 'Smc.C.Generator'
extends 'Smc.Generator'

has.suffix          = { '+', default = 'c' }
has.scopeSep        = { '+', default = '_' }
has.next_generator  = { '+', isa = 'Smc.C.HeaderGenerator',
                        default = function () return require 'Smc.C.HeaderGenerator' end }
has.context         = { is = 'ro', isa = 'string' }

function method:visitFSM (fsm)
    local stream = self.stream
end

function method:visitMap (map)
    local stream = self.stream
end

function method:visitState (state)
    local stream = self.stream
end

function method:visitTransition (transition)
    local stream = self.stream
end

function method:visitGuard (guard)
    local stream = self.stream
end

function method:visitAction (action)
    local stream = self.stream
end

function method:visitParameter (parameter)
end


class 'Smc.C.HeaderGenerator'
extends 'Smc.Generator'

has.suffix          = { '+', default = 'h' }
has.context         = { is = 'ro', isa = 'string' } -- XXX

function method:visitFSM (fsm)
    local stream = self.stream

    stream:write "/*\n"
    stream:write " * ex: set ro:\n"
    stream:write " * DO NOT EDIT.\n"
    stream:write " * generated by smc (http://smc.sourceforge.net/)\n"
    stream:write(" * from file : ", fsm.filename, "\n")
    stream:write " */\n"
    stream:write "\n"

    local targetfileCaps = self.targetfileBase:gsub('\\', '_')
    targetfileCaps = targetfileCaps:gsub('/', '_')
    targetfileCaps = targetfileCaps:lower()
    stream:write("#ifndef _H_", targetfileCaps, "\n")
    stream:write("#define _H_", targetfileCaps)

    stream:write "\n"
    stream:write "#include <statemap.h>\n"
    stream:write "\n"

    for _, decl in ipairs(fsm.declareList) do
        stream:write(decl, "\n")
    end

    local context = fsm.context
    local packageName = fsm._package
    if packageName then
        context = packageName .. "_" .. context
    end
    local fsmClassName = fsm.fsmClassname
    stream:write "\n"
    stream:write("struct ", context, ";\n")
    stream:write("struct ", fsmClassName, ";\n")

    stream:write "\n"
    stream:write("struct ", context, "State\n")
    stream:write "{\n"

    if fsm.hasEntryActions then
        stream:write("    void(*Entry)(struct ", fsmClassName, "*);\n")
    end
    if fsm.hasExitActions then
        stream:write("    void(*Exit)(struct ", fsmClassName, "*);\n")
    end
    stream:write "\n"

    for _, trans in ipairs(fsm.transitions) do
        local transName = trans.name
        if transName ~= "Default" then
            stream:write("    void(*", transName, ")(struct ", fsmClassName, "*")
            for _, param in ipairs(trans.parameters) do
                stream:write(", ", param._type)
            end
            stream:write ");\n"
        end
    end

    stream:write "\n"
    stream:write("    void(*Default)(struct ", fsmClassName, "*);\n")
    stream:write "\n"
    stream:write "    STATE_MEMBERS\n"
    stream:write "};\n"
    stream:write "\n"

    for _, map in ipairs(fsm.maps) do
        map:visit(self)
    end

    stream:write "\n"
    stream:write("struct ", fsmClassName, "\n")
    stream:write "{\n"
    stream:write("    FSM_MEMBERS(", context, ")\n")
    stream:write("    struct ", context, " *_owner;\n")
    stream:write "}\n"
    stream:write "\n"

    stream:write("extern void ", fsmClassName, "_Init(struct ", fsmClassName, "*, struct ", context, "*);\n")

    if fsm.hasEntryActions then
        stream:write("extern void ", fsmClassName, "_EnterStartState(struct ", fsmClassName, "*);\n")
    end

    for _, trans in ipairs(fsm.transitions) do
        local transName = trans.name
        if transName ~= "Default" then
            stream:write("extern void ", fsmClassName, "_", transName, "(struct ", fsmClassName, "*")
            for _, param in ipairs(trans.parameters) do
                stream:write(", ", param._type)
            end
            stream:write ");\n"
        end
    end

    stream:write "\n"
    stream:write "#endif\n"
    stream:write "\n"
    stream:write "/*\n"
    stream:write " * Local variables:\n"
    stream:write " *  buffer-read-only: t\n"
    stream:write " * End:\n"
    stream:write " */\n"
end

function method:visitMap (map)
    local stream = self.stream

    local mapName = map.name
    local fsm = map.fsm
    local context = fsm.context
    local packageName = fsm._package
    if packageName then
        context = packageName .. "_" .. context
    end

    for _, state in ipairs(map.states) do
        stream:write("extern const struct ", context, "State ")
        if packageName then
            stream:write(packageName, "_")
        end
        stream:write(mapName, "_", state.instanceName, ";\n")
    end
end

function method:visitState (state)
end

function method:visitTransition (transition)
end

function method:visitGuard (guard)
end

function method:visitAction (action)
end

function method:visitParameter (parameter)
end

