
require 'Coat'

singleton 'Smc.Php'
extends 'Smc.Language'

has.id              = { '+', default = 'PHP' }
has.name            = { '+', default = 'PHP' }
has.option          = { '+', default = '-php' }
has.suffix          = { '+', default = '_sm' }
has.generator       = { '+', isa = 'Smc.Php.Generator',
                        default = function () return require 'Smc.Php.Generator' end }
has.reflectFlag     = { '+', default = true }


class 'Smc.Php.Generator'
extends 'Smc.Generator'

has.suffix          = { '+', default = 'php' }

function method:_build_template ()
    return CodeGen{
        TOP = [[
<?php
/*
 ex: set ro:
 DO NOT EDIT.
 generated by smc (http://github.com/fperrad/lua-Smc)
 from file : ${fsm.filename}
*/

${_preamble()}
${_base_state()}
${fsm.maps:_map()}
${_context()}

/*
 Local variables:
  buffer-read-only: t
 End:
*/
?>
]],
        _preamble = [[
${fsm.source}
require_once 'StateMachine/statemap.php';
${fsm.importList:_import()}
]],
            _import = [[
require_once '${it}';
]],
        _base_state = [[

class ${fsm.context}State extends State {

    public function Entry($fsm) {
    }

    public function Exit_($fsm) {
    }
    ${fsm.transitions:_transition_base_state()}

    public function Default_($fsm) {
        ${generator.debugLevel0?_base_state_debug()}
        $state = $fsm->getState()->getName();
        $transition = $fsm->getTransition();
        $msg = "\n\tState: $state\n\tTransition: $transition";
        throw new TransitionUndefinedException($msg);
    }

}
]],
            _transition_base_state = "${isntDefault?_transition_base_state_if()}\n",
            _transition_base_state_if = [[

public function ${name}($fsm${parameters:_parameter_proto()}) {
    $this->Default_($fsm);
}
]],
                _parameter_proto = ", ${_type?_parameter_type()}${name}",
                    _parameter_type = "${_type} ",
            _base_state_debug = [[
if ($fsm->getDebugFlag() == true) {
    fwrite($fsm->getDebugStream(), "TRANSITION   : Default\n");
}
]],
        _map = [[

class ${name}_Default extends ${fsm.context}State {
    ${defaultState?_map_default_state()}
    ${generator.reflectFlag?_state_reflect()}

}
${states:_state()}

class ${name} {
    ${states:_state_decl()}
    public static $Default_;
}

${states:_state_init()}
${name}::$Default_ = new ${name}_Default('${name}.Default_', -1);
]],
            _map_default_state = "${defaultState.transitions:_transition()}",
            _state_decl = [[
public static $${className};
]],
            _state_init = [[
${map.name}::$${instanceName} = new ${map.name}_${className}('${map.name}.${className}', ${map.nextStateId});
]],
        _state = [[

class ${map.name}_${className} extends ${map.name}_Default {
    ${entryActions?_state_entry()}
    ${exitActions?_state_exit()}
    ${transitions:_transition()}
    ${generator.reflectFlag?_state_reflect()}

}
]],
            _state_entry = [[

public function Entry($fsm) {
    $ctxt = $fsm->getOwner();
    ${entryActions:_action()}
}
]],
            _state_exit = [[

public function Exit_($fsm) {
    $ctxt = $fsm->getOwner();
    ${exitActions:_action()}
}
]],
            _state_reflect = [[

public function getTransitions() {
    return array(
        ${reflect:_reflect()}
    );
}
]],
                _reflect = [[
'${name}' => ${def},
]],
        _transition = [[

public function ${name; format=sanitize}($fsm${parameters:_parameter_proto()}) {
    ${hasCtxtReference?_transition_ctxt()}
    ${generator.debugLevel0?_transition_debug()}
    ${guards:_guard()}
    ${needFinalElse?_transition_else()}
}
]],
            sanitize = function (s)
                if s == 'Default' then
                    return 'Default_'
                else
                    return s
                end
            end,
            _transition_ctxt = [[
$ctxt = $fsm->getOwner();
]],
            _transition_debug = [[
if ($fsm->getDebugFlag() == true) {
    fwrite($fsm->getDebugStream(), "LEAVING STATE   : ${state.map.name}.${state.className}\n");
}
]],
            _transition_else = [[
else {
    parent::${name; format=sanitize}($fsm${parameters:_parameter_call()});
}
]],
                _parameter_call = ", ${name}",
        _guard = "${hasCondition?_guard_conditional()!_guard_unconditional()}",
            _guard_conditional = "${ifCondition?_guard_if()!_guard_no_if()}",
            _guard_no_if = "${elseifCondition?_guard_elseif()!_guard_else()}",
            _guard_unconditional = [[
${_guard_core()}
]],
            _guard_if = [[
if (${condition}) {
    ${_guard_core()}
}
]],
            _guard_elseif = [[

elseif (${condition}) {
    ${_guard_core()}
}
]],
            _guard_else = [[

else {
    ${_guard_core()}
}
]],
            _guard_core = [[
${needVarEndState?_guard_end_state()}
${doesExit?_guard_exit()}
${generator.debugLevel0?_guard_debug_enter()}
${hasActions?_guard_actions()!_guard_no_action()}
${doesEndPop?_guard_end_pop()}
]],
                _guard_end_state = [[
$${varEndState} = $fsm->getState();
]],
                _guard_exit = [[
${generator.debugLevel1?_guard_debug_before_exit()}
$fsm->getState()->Exit_($fsm);
${generator.debugLevel1?_guard_debug_after_exit()}
]],
                    _guard_debug_before_exit = [[
if ($fsm->getDebugFlag() == true) {
    fwrite($fsm->getDebugStream(), "BEFORE EXIT     : ${transition.state.fullName}->Exit_($fsm)\n");
}
]],
                    _guard_debug_after_exit = [[
if ($fsm->getDebugFlag() == true) {
    fwrite($fsm->getDebugStream(), "AFTER EXIT      : ${transition.state.fullName}->Exit_($fsm)\n");
}
]],
                _guard_debug_enter = [[
if ($fsm->getDebugFlag() == true) {
    fwrite($fsm->getDebugStream(), "ENTER TRANSITION: ${transition.state.fullName}->${transition.name}(${transition.parameters:_guard_debug_param(); separator=', '})\n");
}
]],
                    _guard_debug_param = "${name}",
                _guard_no_action = [[
${hasCondition?_guard_no_action_if()}
${_guard_final()}
]],
                    _guard_no_action_if = [[
# No actions.
]],
                _guard_actions = [[
$fsm->clearState();
${generator.catchFlag?_guard_actions_protected()!_guard_actions_not_protected()}
]],
                    _guard_actions_protected = [[
$exception = NULL;
try {
    ${actions:_action()}
}
catch (Exception $exception) {}
${_guard_final()}
if ($exception != NULL) {
    throw $exception;
}
]],
                    _guard_actions_not_protected = [[
${actions:_action()}
${_guard_final()}
]],
                            _guard_final = [[
${generator.debugLevel0?_guard_debug_exit()}
${doesSet?_guard_set()}
${doesPush?_guard_push()}
${doesPop?_guard_pop()}
${doesEntry?_guard_entry()}
]],
                _guard_debug_exit = [[
if ($fsm->getDebugFlag() == true) {
    fwrite($fsm->getDebugStream(), "EXIT TRANSITION : ${transition.state.fullName}->${transition.name}(${transition.parameters:_guard_debug_param(); separator=', '})\n");
}
]],
                _guard_set = [[
$fsm->setState(${varEndState; format=scoped});
]],
                scoped = function (s)
                    if s == 'endState' then
                        return '$endState'
                    end
                    return s:gsub("::", "::$")
                end,
                _guard_push = [[
${doesPushSet?_guard_set()}
${doesPushEntry?_guard_entry()}
$fsm->pushState(${pushStateName; format=scoped});
]],
                _guard_pop = [[
$fsm->popState();
]],
                _guard_entry = [[
${generator.debugLevel1?_guard_debug_before_entry()}
$fsm->getState()->Entry($fsm);
${generator.debugLevel1?_guard_debug_after_entry()}
]],
                    _guard_debug_before_entry = [[
if ($fsm->getDebugFlag() == true) {
    fwrite($fsm->getDebugStream(), "BEFORE ENTRY    : ${transition.state.fullName}->Entry($fsm)\n");
}
]],
                    _guard_debug_after_entry = [[
if ($fsm->getDebugFlag() == true) {
    fwrite($fsm->getDebugStream(), "AFTER ENTRY     : ${transition.state.fullName}->Entry($fsm)\n");
}
]],
                _guard_end_pop = [[
$fsm->${endStateName}(${popArgs});
]],
        _action = "${isEmptyStateStack?_action_ess()!_action_no_ess()}\n",
            _action_ess = [[
$fsm->emptyStateStack();
]],
            _action_no_ess = [[
$ctxt->${name}(${arguments; separator=', '});
]],
        _context = [[

class ${fsm.context}_sm extends FSMContext {

    public function __construct($owner) {
        parent::__construct(${fsm.startState; format=scoped});
        $this->_owner = $owner;
    }
    ${fsm.transitions:_transition_context()}

    public function getState() {
        if ($this->_state == NULL) {
            throw new StateUndefinedException();
        }
        return $this->_state;
    }

    public function enterStartState() {
        $this->_state->Entry($this);
    }

    public function getOwner() {
        return $this->_owner;
    }

    ${generator.reflectFlag?_context_reflect()}
}
]],
            _transition_context = "${isntDefault?_transition_context_if()}\n",
            _transition_context_if = [[

public function ${name} (${parameters:_parameter_proto_context(); separator=", "}) {
    $this->_transition = "${name}";
    $this->getState()->${name}($this${parameters:_parameter_call()});
    $this->_transition = NULL;
}
]],
                _parameter_proto_context = "${_type?_parameter_type()}${name}",
            _context_reflect = [[
public function getStates() {
    return array(
        ${fsm.maps:_map_context_reflect()}
    );
}

public function getTransitions() {
    return array(
        ${fsm.transitions:_transition_context_reflect()}
    );
}

]],
                _map_context_reflect = "${states:_state_context_reflect()}\n",
                     _state_context_reflect = [[
${map.name}::$${className},
]],
                _transition_context_reflect = [[
'${name}',
]],
    }
end
