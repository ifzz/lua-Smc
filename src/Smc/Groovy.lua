
require 'Coat'

singleton 'Smc.Groovy'
extends 'Smc.Language'

has.id              = { '+', default = 'GROOVY' }
has.name            = { '+', default = 'Groovy' }
has.option          = { '+', default = '-groovy' }
has.suffix          = { '+', default = 'Context' }
has.generator       = { '+', isa = 'Smc.Groovy.Generator',
                        default = function () return require 'Smc.Groovy.Generator' end }
has.reflectFlag     = { '+', default = true }
has.serialFlag      = { '+', default = true }
has.syncFlag        = { '+', default = true }


class 'Smc.Groovy.Generator'
extends 'Smc.Generator'

has.suffix          = { '+', default = 'groovy' }

function method:_build_template ()
    return CodeGen{
        TOP = [[
// ex: set ro:
// DO NOT EDIT.
// generated by smc (http://github.com/fperrad/lua-Smc)
// from file : ${fsm.filename}

${_preamble()}
${_context()}
${_base_state()}
${fsm.maps:_map()}

// Local variables:
//  buffer-read-only: t
// End:
]],
        _preamble = [[
${fsm.source}
${fsm._package?__package()}
${fsm.importList:_import()}
]],
            __package = [[

package ${fsm._package; format=scoped}
]],
            _import = [[
import ${it}
]],
        _context = [[

class ${fsm.fsmClassname} extends statemap.FSMContext${generator.serialFlag?_serializable()} {

    def owner

    def ${fsm.fsmClassname} (owner) {
        super(${fsm.startState; format=scoped})

        this.owner = owner
    }

    def ${fsm.fsmClassname} (owner, initState) {
        super(initState)

        this.owner = owner
    }

    def enterStartState () {
        state.Entry(this)
    }
    ${fsm.transitions:_transition_context()}
    ${generator.reflectFlag?_context_reflect()}
}
]],
            scoped = function (str) return str:gsub('::','.') end,
            _serializable = " implements Serializable",
            _transition_context = "${isntDefault?_transition_context_if()}\n",
            _transition_context_if = [[

${generator.syncFlag?_def_synchronized()!_def()} ${name} (${parameters:_parameter_proto_context(); separator=", "}) {
    transition = '${name}'
    state.${name}(this${parameters:_parameter_call_context()})
    transition = ''
}
]],
                _def_synchronized = "synchronized void",
                _def = "def",
                _parameter_proto_context = "${_type?_parameter_type()}${name}",
                     _parameter_type = "${_type} ",
                _parameter_call_context = ", ${name}",
            _context_reflect = [[

final states = [
    ${fsm.maps:_map_context_reflect(); separator=",\n"}
]

final transitions = [
    ${fsm.transitions:_transition_context_reflect(); separator=",\n"}
]
]],
                _map_context_reflect = '${states:_state_context_reflect(); separator=",\\n"}',
                     _state_context_reflect = [[
${map.name}.${className}
]],
                _transition_context_reflect = [[
'${name}'
]],
        _base_state = [[

private class ${fsm.context}State extends statemap.State {

    def Entry (${fsm.fsmClassname} context) {}
    def Exit (${fsm.fsmClassname} context) {}
    ${fsm.transitions:_transition_base_state()}

    def Default (${fsm.fsmClassname} context) {
        ${generator.debugLevel0?_base_state_debug()}
        throw new statemap.TransitionUndefinedException(
                'State: ' + context.state.name +
                ', Transition: ' + context.transition)
    }
}
]],
            _transition_base_state = "${isntDefault?_transition_base_state_if()}\n",
            _transition_base_state_if = [[

def ${name} (${fsm.fsmClassname} context${parameters:_parameter_proto()}) {
    Default(context)
}
]],
                _parameter_proto = ", ${_type?_parameter_type()}${name}",
            _base_state_debug = [[
        if (context.debugFlag)
            context.debugStream.println 'TRANSITION   : Default'

]],
        _map = [[

private class ${name}_Default extends ${fsm.context}State {
    ${defaultState?_map_default_state()}
    ${generator.reflectFlag?_default_state_reflect()}
}
${states:_state()}

class ${name} {
    ${states:_state_init()}
    static final Default = new ${name}_Default(name:'${name}.Default', id:-1)
}
]],
            _map_default_state = "${defaultState.transitions:_transition()}",
            _default_state_reflect = [[

def transitions = [
    ${reflect:_reflect(); separator=",\n"}
]
]],
            _state_init = [[
static final ${instanceName} = new ${map.name}_${className}(name:'${map.name}.${className}', id:${map.nextStateId})
]],
        _state = [[

private class ${map.name}_${className} extends ${map.name}_Default {
    ${entryActions?_state_entry()}
    ${exitActions?_state_exit()}
    ${transitions:_transition()}
    ${generator.reflectFlag?_state_reflect()}
}
]],
            _state_entry = [[

def Entry (${map.fsm.fsmClassname} context) {
    def ctxt = context.owner

    ${entryActions:_action()}
}
]],
            _state_exit = [[

def Exit (${map.fsm.fsmClassname} context) {
    def ctxt = context.owner

    ${exitActions:_action()}
}
]],
            _state_reflect = [[

final transitions = [
    ${reflect:_reflect(); separator=",\n"}
]
]],
                _reflect = [[
${name}:${def}
]],
        _transition = [[

def ${name}(${fsm.fsmClassname} context${parameters:_parameter_proto()}) {
    ${hasCtxtReference?_transition_ctxt()}
    ${generator.debugLevel0?_transition_debug()}
    ${guards:_guard()}
    ${needFinalElse?_transition_else()}
}
]],
            _transition_ctxt = [[
def ctxt = context.owner

]],
            _transition_debug = [[
if (context.debugFlag)
    context.debugStream.println('LEAVING STATE   : ${state.map.name}.${state.className}')
]],
            _transition_else = [[
else {
    super.${name}(context${parameters:_parameter_call()})
}
]],
                _parameter_call = ", ${name}",
        _guard = "${hasCondition?_guard_conditional()!_guard_unconditional()}",
            _guard_conditional = "${ifCondition?_guard_if()!_guard_no_if()}",
            _guard_no_if = "${elseifCondition?_guard_elseif()!_guard_else()}",
            _guard_unconditional = [[
${_guard_core()}
]],
            _guard_if = [[
if (${condition}) {
    ${_guard_core()}
}
]],
            _guard_elseif = [[

else if (${condition}) {
    ${_guard_core()}
}
]],
            _guard_else = [[

else {
    ${_guard_core()}
}
]],
                _guard_core = [[
${needVarEndState?_guard_end_state()}
${doesExit?_guard_exit()}
${generator.debugLevel0?_guard_debug_enter()}
${hasActions?_guard_actions()!_guard_no_action()}
${doesEndPop?_guard_end_pop()}
]],
                    _guard_end_state = [[
def endState = context.state
]],
                    _guard_exit = [[
${generator.debugLevel1?_guard_debug_before_exit()}
context.state.Exit(context)
${generator.debugLevel1?_guard_debug_after_exit()}
]],
                        _guard_debug_before_exit = [[
if (context.debugFlag)
    context.debugStream.println('BEFORE EXIT     : ${transition.state.fullName}.Exit(fsm)')
]],
                        _guard_debug_after_exit = [[
if (context.debugFlag)
    context.debugStream.println('AFTER EXIT      : ${transition.state.fullName}.Exit(fsm)')
]],
                    _guard_debug_enter = [[
if (context.debugFlag)
    context.debugStream.println('ENTER TRANSITION: ${transition.state.fullName}.${transition.name}(${transition.parameters:_parameter_proto_context(); separator=', '})')
]],
                    _guard_no_action = [[
${hasCondition?_guard_no_action_if()}
${_guard_final()}
]],
                        _guard_no_action_if = [[
// No actions.
]],
                    _guard_actions = [[
context.clearState()
${generator.catchFlag?_guard_actions_protected()!_guard_actions_not_protected()}
]],
                        _guard_actions_protected = [[
try {
    ${actions:_action()}
}
finally {
    ${_guard_final()}
}
]],
                        _guard_actions_not_protected = [[
${actions:_action()}
${_guard_final()}
]],
                            _guard_final = [[
${generator.debugLevel0?_guard_debug_exit()}
${doesSet?_guard_set()}
${doesPush?_guard_push()}
${doesPop?_guard_pop()}
${doesEntry?_guard_entry()}
]],
                                _guard_debug_exit = [[
if (context.debugFlag)
    context.debugStream.println('EXIT TRANSITION : ${transition.state.fullName}.${transition.name}(${transition.parameters:_parameter_proto_context(); separator=', '})')
]],
                                _guard_set = [[
context.setState(${needVarEndState?_end_state_var()!_end_state_no_var()})
]],
                                    _end_state_var = "endState",
                                    _end_state_no_var = "${endStateName; format=scoped}",
                                _guard_push = [[
${doesPushSet?_guard_set()}
${doesPushEntry?_guard_entry()}
context.pushState(${pushStateName; format=scoped})
]],
                                _guard_pop = [[
context.popState()
]],
                                _guard_entry = [[
${generator.debugLevel1?_guard_debug_before_entry()}
context.state.Entry(context)
${generator.debugLevel1?_guard_debug_after_entry()}
]],
                                    _guard_debug_before_entry = [[
if (context.debugFlag)
    context.debugStream.println('BEFORE ENTRY    : ${transition.state.fullName}.Exit(fsm)')
]],
                                    _guard_debug_after_entry = [[
if (context.debugFlag)
    context.debugStream.println('AFTER ENTRY     : ${transition.state.fullName}.Exit(fsm)')
]],
                                _guard_end_pop = [[
context.${endStateName}(${popArgs})
]],
        _action = "${propertyFlag?_action_prop()!_action_no_prop()}\n",
            _action_no_prop = "${isEmptyStateStack?_action_ess()!_action_no_ess()}",
            _action_prop = [[
ctxt.${name} = ${arguments}
]],
                _action_ess = [[
context.emptyStateStack()
]],
                _action_no_ess = [[
ctxt.${name}(${arguments; separator=', '})
]],
    }
end
